{{- if .Values.useFalcoSandboxRules }}
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: {{ include "falco.namespace" . }}
  name: falco-sandbox-rules
data:
  falco-sandbox_rules.yaml: "#\n# Copyright (C) 2023 The Falco Authors.\n#\n#\n# Licensed
    under the Apache License, Version 2.0 (the \"License\");\n# you may not use this
    file except in compliance with the License.\n# You may obtain a copy of the License
    at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required
    by applicable law or agreed to in writing, software\n# distributed under the License
    is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.\n# See the License for the specific language
    governing permissions and\n# limitations under the License.\n#\n\n# Information
    about rules tags and fields can be found here: https://falco.org/docs/rules/#tags-for-current-falco-ruleset\n#
    The initial item in the `tags` fields reflects the maturity level of the rules
    introduced upon the proposal https://github.com/falcosecurity/rules/blob/main/proposals/20230605-rules-adoption-management-maturity-framework.md\n#
    `tags` fields also include information about the type of workload inspection (host
    and/or container), and Mitre Attack killchain phases and Mitre TTP code(s)\n#
    Mitre Attack References:\n# [1] https://attack.mitre.org/tactics/enterprise/\n#
    [2] https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/enterprise-attack.json\n\n#
    Starting with version 8, the Falco engine supports exceptions.\n# However the
    Falco rules file does not use them by default.\n- required_engine_version: 26\n\n#
    Currently disabled as read/write are ignored syscalls. The nearly\n# similar open_write/open_read
    check for files being opened for\n# reading/writing.\n# - macro: write\n#   condition:
    (syscall.type=write and fd.type in (file, directory))\n# - macro: read\n#   condition:
    (syscall.type=read and evt.dir=> and fd.type in (file, directory))\n\n- macro:
    open_write\n  condition: (evt.type in (open,openat,openat2) and evt.is_open_write=true
    and fd.typechar='f' and fd.num>=0)\n\n- macro: open_read\n  condition: (evt.type
    in (open,openat,openat2) and evt.is_open_read=true and fd.typechar='f' and fd.num>=0)\n\n#
    This macro `never_true` is used as placeholder for tuning negative logical sub-expressions,
    for example\n# - macro: allowed_ssh_hosts\n#   condition: (never_true)\n# can
    be used in a rules' expression with double negation `and not allowed_ssh_hosts`
    which effectively evaluates\n# to true and does nothing, the perfect empty template
    for `logical` cases as opposed to list templates.\n# When tuning the rule you
    can override the macro with something useful, e.g.\n# - macro: allowed_ssh_hosts\n#
    \  condition: (evt.hostname contains xyz)\n- macro: never_true\n  condition: (evt.num=0)\n\n#
    This macro `always_true` is the flip side of the macro `never_true` and currently
    is commented out as\n# it is not used. You can use it as placeholder for a positive
    logical sub-expression tuning template\n# macro, e.g. `and custom_procs`, where\n#
    - macro: custom_procs\n#   condition: (always_true)\n# later you can customize,
    override the macros to something like\n# - macro: custom_procs\n#   condition:
    (proc.name in (custom1, custom2, custom3))\n# - macro: always_true\n#   condition:
    (evt.num>=0)\n\n# In some cases, such as dropped system call events, information
    about\n# the process name may be missing. For some rules that really depend\n#
    on the identity of the process performing an action such as opening\n# a file,
    etc., we require that the process name be known.\n- macro: proc_name_exists\n
    \ condition: (proc.name!=\"<NA>\")\n\n- macro: rename\n  condition: (evt.type
    in (rename, renameat, renameat2))\n\n- macro: mkdir\n  condition: (evt.type in
    (mkdir, mkdirat))\n\n- macro: remove\n  condition: (evt.type in (rmdir, unlink,
    unlinkat))\n\n- macro: modify\n  condition: (rename or remove)\n\n- macro: spawned_process\n
    \ condition: (evt.type in (execve, execveat) and evt.dir=<)\n\n- macro: chmod\n
    \ condition: (evt.type in (chmod, fchmod, fchmodat) and evt.dir=<)\n\n# File categories\n-
    macro: bin_dir\n  condition: (fd.directory in (/bin, /sbin, /usr/bin, /usr/sbin))\n\n-
    macro: bin_dir_mkdir\n  condition: >\n     (evt.arg.path startswith /bin/ or\n
    \    evt.arg.path startswith /sbin/ or\n     evt.arg.path startswith /usr/bin/
    or\n     evt.arg.path startswith /usr/sbin/)\n\n- macro: bin_dir_rename\n  condition:
    >\n     (evt.arg.path startswith /bin/ or\n     evt.arg.path startswith /sbin/
    or\n     evt.arg.path startswith /usr/bin/ or\n     evt.arg.path startswith /usr/sbin/
    or\n     evt.arg.name startswith /bin/ or\n     evt.arg.name startswith /sbin/
    or\n     evt.arg.name startswith /usr/bin/ or\n     evt.arg.name startswith /usr/sbin/
    or\n     evt.arg.oldpath startswith /bin/ or\n     evt.arg.oldpath startswith
    /sbin/ or\n     evt.arg.oldpath startswith /usr/bin/ or\n     evt.arg.oldpath
    startswith /usr/sbin/ or\n     evt.arg.newpath startswith /bin/ or\n     evt.arg.newpath
    startswith /sbin/ or\n     evt.arg.newpath startswith /usr/bin/ or\n     evt.arg.newpath
    startswith /usr/sbin/)\n\n- macro: etc_dir\n  condition: (fd.name startswith /etc/)\n\n#
    This detects writes immediately below / or any write anywhere below /root\n- macro:
    root_dir\n  condition: (fd.directory=/ or fd.name startswith /root/)\n\n- list:
    shell_binaries\n  items: [ash, bash, csh, ksh, sh, tcsh, zsh, dash]\n\n- list:
    shell_mgmt_binaries\n  items: [add-shell, remove-shell]\n\n# dpkg -L passwd |
    grep bin | xargs ls -ld | grep -v '^d' | awk '{print $9}' | xargs -L 1 basename
    | tr \"\\\\n\" \",\"\n- list: passwd_binaries\n  items: [\n    shadowconfig, grpck,
    pwunconv, grpconv, pwck,\n    groupmod, vipw, pwconv, useradd, newusers, cppw,
    chpasswd, usermod,\n    groupadd, groupdel, grpunconv, chgpasswd, userdel, chage,
    chsh,\n    gpasswd, chfn, expiry, passwd, vigr, cpgr, adduser, addgroup, deluser,
    delgroup\n    ]\n\n# repoquery -l shadow-utils | grep bin | xargs ls -ld | grep
    -v '^d' |\n#     awk '{print $9}' | xargs -L 1 basename | tr \"\\\\n\" \",\"\n-
    list: shadowutils_binaries\n  items: [\n    chage, gpasswd, lastlog, newgrp, sg,
    adduser, deluser, chpasswd,\n    groupadd, groupdel, addgroup, delgroup, groupmems,
    groupmod, grpck, grpconv, grpunconv,\n    newusers, pwck, pwconv, pwunconv, useradd,
    userdel, usermod, vigr, vipw, unix_chkpwd\n    ]\n\n- list: sysdigcloud_binaries\n
    \ items: [setup-backend, dragent, sdchecks]\n\n- list: interpreted_binaries\n
    \ items: [lua, node, perl, perl5, perl6, php, python, python2, python3, ruby,
    tcl]\n\n- macro: interpreted_procs\n  condition: >\n    (proc.name in (interpreted_binaries))\n\n#
    The explicit quotes are needed to avoid the - characters being\n# interpreted
    by the filter expression.\n- list: rpm_binaries\n  items: [dnf, dnf-automatic,
    rpm, rpmkey, yum, '\"75-system-updat\"', rhsmcertd-worke, rhsmcertd, subscription-ma,\n
    \         repoquery, rpmkeys, rpmq, yum-cron, yum-config-mana, yum-debug-dump,\n
    \         abrt-action-sav, rpmdb_stat, microdnf, rhn_check, yumdb]\n\n- list:
    openscap_rpm_binaries\n  items: [probe_rpminfo, probe_rpmverify, probe_rpmverifyfile,
    probe_rpmverifypackage]\n\n- macro: rpm_procs\n  condition: (proc.name in (rpm_binaries,
    openscap_rpm_binaries) or proc.name in (salt-call, salt-minion))\n\n- list: deb_binaries\n
    \ items: [dpkg, dpkg-preconfigu, dpkg-reconfigur, dpkg-divert, apt, apt-get, aptitude,\n
    \   frontend, preinst, add-apt-reposit, apt-auto-remova, apt-key,\n    apt-listchanges,
    unattended-upgr, apt-add-reposit, apt-cache, apt.systemd.dai\n    ]\n- list: python_package_managers\n
    \ items: [pip, pip3, conda]\n\n# The truncated dpkg-preconfigu is intentional,
    process names are\n# truncated at the falcosecurity-libs level.\n- list: package_mgmt_binaries\n
    \ items: [rpm_binaries, deb_binaries, update-alternat, gem, npm, python_package_managers,
    sane-utils.post, alternatives, chef-client, apk, snapd]\n\n- macro: package_mgmt_procs\n
    \ condition: (proc.name in (package_mgmt_binaries))\n\n- macro: package_mgmt_ancestor_procs\n
    \ condition: (proc.pname in (package_mgmt_binaries) or\n             proc.aname[2]
    in (package_mgmt_binaries) or\n             proc.aname[3] in (package_mgmt_binaries)
    or\n             proc.aname[4] in (package_mgmt_binaries))\n\n- macro: coreos_write_ssh_dir\n
    \ condition: (proc.name=update-ssh-keys and fd.name startswith /home/core/.ssh)\n\n-
    list: ssl_mgmt_binaries\n  items: [ca-certificates]\n\n- list: dhcp_binaries\n
    \ items: [dhclient, dhclient-script, 11-dhclient]\n\n- list: dev_creation_binaries\n
    \ items: [blkid, rename_device, update_engine, sgdisk]\n\n- list: nomachine_binaries\n
    \ items: [nxexec, nxnode.bin, nxserver.bin, nxclient.bin]\n\n- list: mail_config_binaries\n
    \ items: [\n    update_conf, parse_mc, makemap_hash, newaliases, update_mk, update_tlsm4,\n
    \   update_db, update_mc, ssmtp.postinst, mailq, postalias, postfix.config.,\n
    \   postfix.config, postfix-script, postconf\n    ]\n\n# Network\n- macro: inbound\n
    \ condition: >\n    (((evt.type in (accept,accept4,listen) and evt.dir=<) or\n
    \     (evt.type in (recvfrom,recvmsg) and evt.dir=< and\n       fd.l4proto !=
    tcp and fd.connected=false and fd.name_changed=true)) and\n     (fd.typechar =
    4 or fd.typechar = 6) and\n     (fd.ip != \"0.0.0.0\" and fd.net != \"127.0.0.0/8\")
    and\n     (evt.rawres >= 0 or evt.res = EINPROGRESS))\n\n# RFC1918 addresses were
    assigned for private network usage\n- list: rfc_1918_addresses\n  items: ['\"10.0.0.0/8\"',
    '\"172.16.0.0/12\"', '\"192.168.0.0/16\"']\n\n- macro: outbound\n  condition:
    >\n    (((evt.type = connect and evt.dir=<) or\n      (evt.type in (sendto,sendmsg)
    and evt.dir=< and\n       fd.l4proto != tcp and fd.connected=false and fd.name_changed=true))
    and\n     (fd.typechar = 4 or fd.typechar = 6) and\n     (fd.ip != \"0.0.0.0\"
    and fd.net != \"127.0.0.0/8\" and not fd.snet in (rfc_1918_addresses)) and\n     (evt.rawres
    >= 0 or evt.res = EINPROGRESS))\n\n# Very similar to inbound/outbound, but combines
    the tests together\n# for efficiency.\n- macro: inbound_outbound\n  condition:
    >\n    ((((evt.type in (accept,accept4,listen,connect) and evt.dir=<)) and\n     (fd.typechar
    = 4 or fd.typechar = 6)) and\n     (fd.ip != \"0.0.0.0\" and fd.net != \"127.0.0.0/8\")
    and\n     (evt.rawres >= 0 or evt.res = EINPROGRESS))\n\n- list: allowed_inbound_source_ipaddrs\n
    \ items: ['\"127.0.0.1\"']\n\n- list: allowed_inbound_source_networks\n  items:
    ['\"127.0.0.1/8\"', '\"10.0.0.0/8\"']\n\n- list: allowed_inbound_source_domains\n
    \ items: [google.com]\n\n- rule: Unexpected inbound connection source\n  desc:
    > \n    Detect any inbound connection from a source outside of an allowed set
    of ips, networks, or domain names. \n    This rule absolutely requires profiling
    your environment beforehand. Network-based rules are extremely crucial \n    in
    any security program, as they can often provide the only definitive evidence.
    However, effectively operationalizing \n    them can be challenging due to the
    potential for noise.\n  condition: >\n    inbound \n    and not ((fd.cip in (allowed_inbound_source_ipaddrs))
    or\n             (fd.cnet in (allowed_inbound_source_networks)) or\n             (fd.cip.name
    in (allowed_inbound_source_domains)))\n  enabled: false\n  output: Disallowed
    inbound connection source (connection=%fd.name lport=%fd.lport rport=%fd.rport
    fd_type=%fd.type fd_proto=fd.l4proto evt_type=%evt.type user=%user.name user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: NOTICE\n  tags: [maturity_sandbox, host, container, network, mitre_command_and_control,
    TA0011]\n\n- list: bash_config_filenames\n  items: [.bashrc, .bash_profile, .bash_history,
    .bash_login, .bash_logout, .inputrc, .profile]\n\n- list: bash_config_files\n
    \ items: [/etc/profile, /etc/bashrc]\n\n# Covers both csh and tcsh\n- list: csh_config_filenames\n
    \ items: [.cshrc, .login, .logout, .history, .tcshrc, .cshdirs]\n\n- list: csh_config_files\n
    \ items: [/etc/csh.cshrc, /etc/csh.login]\n\n- list: zsh_config_filenames\n  items:
    [.zshenv, .zprofile, .zshrc, .zlogin, .zlogout]\n\n- list: shell_config_filenames\n
    \ items: [bash_config_filenames, csh_config_filenames, zsh_config_filenames]\n\n-
    list: shell_config_files\n  items: [bash_config_files, csh_config_files]\n\n-
    list: shell_config_directories\n  items: [/etc/zsh]\n\n# This rule is not enabled
    by default, as there are many legitimate\n# readers of shell config files.\n-
    rule: Read Shell Configuration File\n  desc: > \n    This rule detects attempts
    made by non-shell programs to read shell configuration files. It offers additional
    generic auditing. \n    It serves as a baseline detection alert for unusual shell
    configuration file accesses. The rule \"Modify Shell Configuration File\" \n    might
    be more relevant and adequate for your specific cases.\n  condition: >\n    open_read\n
    \   and (fd.filename in (shell_config_filenames) or\n         fd.name in (shell_config_files)
    or\n         fd.directory in (shell_config_directories)) \n    and not proc.name
    in (shell_binaries)\n  enabled: false\n  output: A shell configuration file was
    read by a non-shell program (file=%fd.name evt_type=%evt.type user=%user.name
    user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath
    parent=%proc.pname command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags
    %container.info)\n  priority:\n    WARNING\n  tags: [maturity_sandbox, host, container,
    filesystem, mitre_discovery, T1546.004]\n\n# Use this to test whether the event
    occurred within a container.\n# When displaying container information in the output
    field, use\n# %container.info, without any leading term (file=%fd.name\n# %container.info
    user=%user.name user_loginuid=%user.loginuid, and not file=%fd.name\n# container=%container.info
    user=%user.name user_loginuid=%user.loginuid). The output will change\n# based
    on the context and whether or not -pk/-pm/-pc was specified on\n# the command
    line.\n- macro: container\n  condition: (container.id != host)\n\n- macro: container_started\n
    \ condition: >\n    ((evt.type = container or\n     (spawned_process and proc.vpid=1))
    and\n     container.image.repository != incomplete)\n\n# Possible scripts run
    by sshkit\n- list: sshkit_script_binaries\n  items: [10_etc_sudoers., 10_passwd_group]\n\n-
    list: plesk_binaries\n  items: [sw-engine, sw-engine-fpm, sw-engine-kv, filemng,
    f2bmng]\n\n- macro: httpd_writing_ssl_conf\n  condition: >\n    (proc.pname=run-httpd
    and\n     (proc.cmdline startswith \"sed -ri\" or proc.cmdline startswith \"sed
    -i\") and\n     (fd.name startswith /etc/httpd/conf.d/ or fd.name startswith /etc/httpd/conf))\n\n-
    macro: userhelper_writing_etc_security\n  condition: (proc.name=userhelper and
    fd.name startswith /etc/security)\n\n- macro: ansible_running_python\n  condition:
    (proc.name in (python, pypy, python3) and proc.cmdline contains ansible)\n\n-
    macro: python_running_chef\n  condition: (proc.name=python and (proc.cmdline contains
    yum-dump.py or proc.cmdline=\"python /usr/bin/chef-monitor.py\"))\n\n- macro:
    python_running_denyhosts\n  condition: >\n    (proc.name=python and\n    (proc.cmdline
    contains /usr/sbin/denyhosts or\n     proc.cmdline contains /usr/local/bin/denyhosts.py))\n\n-
    macro: run_by_chef\n  condition: (proc.aname[2]=chef_command_wr or proc.aname[3]=chef_command_wr
    or\n              proc.aname[2]=chef-client or proc.aname[3]=chef-client or\n
    \             proc.name=chef-client)\n\n- macro: run_by_adclient\n  condition:
    (proc.aname[2]=adclient or proc.aname[3]=adclient or proc.aname[4]=adclient)\n\n-
    macro: run_by_centrify\n  condition: (proc.aname[2]=centrify or proc.aname[3]=centrify
    or proc.aname[4]=centrify)\n\n- macro: parent_supervise_running_multilog\n  condition:
    (proc.name=multilog and proc.pname=supervise)\n\n- macro: supervise_writing_status\n
    \ condition: (proc.name in (supervise,svc) and fd.name startswith \"/etc/sb/\")\n\n-
    macro: pki_realm_writing_realms\n  condition: (proc.cmdline startswith \"bash
    /usr/local/lib/pki/pki-realm\" and fd.name startswith /etc/pki/realms)\n\n- macro:
    htpasswd_writing_passwd\n  condition: (proc.name=htpasswd and fd.name=/etc/nginx/.htpasswd)\n\n-
    macro: lvprogs_writing_conf\n  condition: >\n    (proc.name in (dmeventd,lvcreate,pvscan,lvs)
    and\n     (fd.name startswith /etc/lvm/archive or\n      fd.name startswith /etc/lvm/backup
    or\n      fd.name startswith /etc/lvm/cache))\n\n- macro: ovsdb_writing_openvswitch\n
    \ condition: (proc.name=ovsdb-server and fd.directory=/etc/openvswitch)\n\n- macro:
    parent_ucf_writing_conf\n  condition: (proc.pname=ucf and proc.aname[2]=frontend)\n\n-
    macro: consul_template_writing_conf\n  condition: >\n    ((proc.name=consul-template
    and fd.name startswith /etc/haproxy) or\n     (proc.name=reload.sh and proc.aname[2]=consul-template
    and fd.name startswith /etc/ssl))\n\n- macro: countly_writing_nginx_conf\n  condition:
    (proc.cmdline startswith \"nodejs /opt/countly/bin\" and fd.name startswith /etc/nginx)\n\n-
    list: ms_oms_binaries\n  items: [omi.postinst, omsconfig.posti, scx.postinst,
    omsadmin.sh, omiagent]\n\n- macro: ms_oms_writing_conf\n  condition: >\n    ((proc.name
    in (omiagent,omsagent,in_heartbeat_r*,omsadmin.sh,PerformInventor,dsc_host)\n
    \      or proc.pname in (ms_oms_binaries)\n       or proc.aname[2] in (ms_oms_binaries))\n
    \    and (fd.name startswith /etc/opt/omi or fd.name startswith /etc/opt/microsoft/omsagent))\n\n-
    macro: ms_scx_writing_conf\n  condition: (proc.name in (GetLinuxOS.sh) and fd.name
    startswith /etc/opt/microsoft/scx)\n\n- macro: azure_scripts_writing_conf\n  condition:
    (proc.pname startswith \"bash /var/lib/waagent/\" and fd.name startswith /etc/azure)\n\n-
    macro: azure_networkwatcher_writing_conf\n  condition: (proc.name in (NetworkWatcherA)
    and fd.name=/etc/init.d/AzureNetworkWatcherAgent)\n\n- macro: couchdb_writing_conf\n
    \ condition: (proc.name=beam.smp and proc.cmdline contains couchdb and fd.name
    startswith /etc/couchdb)\n\n- macro: update_texmf_writing_conf\n  condition: (proc.name=update-texmf
    and fd.name startswith /etc/texmf)\n\n- macro: slapadd_writing_conf\n  condition:
    (proc.name=slapadd and fd.name startswith /etc/ldap)\n\n- macro: openldap_writing_conf\n
    \ condition: (proc.pname=run-openldap.sh and fd.name startswith /etc/openldap)\n\n-
    macro: ucpagent_writing_conf\n  condition: (proc.name=apiserver and container.image.repository=docker/ucp-agent
    and fd.name=/etc/authorization_config.cfg)\n\n- macro: iscsi_writing_conf\n  condition:
    (proc.name=iscsiadm and fd.name startswith /etc/iscsi)\n\n- macro: istio_writing_conf\n
    \ condition: (proc.name=pilot-agent and fd.name startswith /etc/istio)\n\n- macro:
    symantec_writing_conf\n  condition: >\n    ((proc.name=symcfgd and fd.name startswith
    /etc/symantec) or\n     (proc.name=navdefutil and fd.name=/etc/symc-defutils.conf))\n\n-
    macro: liveupdate_writing_conf\n  condition: (proc.cmdline startswith \"java LiveUpdate\"
    and fd.name in (/etc/liveupdate.conf, /etc/Product.Catalog.JavaLiveUpdate))\n\n-
    macro: sosreport_writing_files\n  condition: >\n    (proc.name=urlgrabber-ext-
    and proc.aname[3]=sosreport and\n     (fd.name startswith /etc/pkt/nssdb or fd.name
    startswith /etc/pki/nssdb))\n\n- macro: pkgmgmt_progs_writing_pki\n  condition:
    >\n    (proc.name=urlgrabber-ext- and proc.pname in (yum, yum-cron, repoquery)
    and\n     (fd.name startswith /etc/pkt/nssdb or fd.name startswith /etc/pki/nssdb))\n\n-
    macro: update_ca_trust_writing_pki\n  condition: (proc.pname=update-ca-trust and
    proc.name=trust and fd.name startswith /etc/pki)\n\n- macro: brandbot_writing_os_release\n
    \ condition: (proc.name=brandbot and fd.name=/etc/os-release)\n\n- macro: selinux_writing_conf\n
    \ condition: (proc.name in (semodule,genhomedircon,sefcontext_comp) and fd.name
    startswith /etc/selinux)\n\n- list: veritas_binaries\n  items: [vxconfigd, sfcache,
    vxclustadm, vxdctl, vxprint, vxdmpadm, vxdisk, vxdg, vxassist, vxtune]\n\n- macro:
    veritas_driver_script\n  condition: (proc.cmdline startswith \"perl /opt/VRTSsfmh/bin/mh_driver.pl\")\n\n-
    macro: veritas_progs\n  condition: (proc.name in (veritas_binaries) or veritas_driver_script)\n\n-
    macro: veritas_writing_config\n  condition: (veritas_progs and (fd.name startswith
    /etc/vx or fd.name startswith /etc/opt/VRTS or fd.name startswith /etc/vom))\n\n-
    macro: nginx_writing_conf\n  condition: (proc.name in (nginx,nginx-ingress-c,nginx-ingress)
    and (fd.name startswith /etc/nginx or fd.name startswith /etc/ingress-controller))\n\n-
    macro: nginx_writing_certs\n  condition: >\n    (((proc.name=openssl and proc.pname=nginx-launch.sh)
    or proc.name=nginx-launch.sh) and fd.name startswith /etc/nginx/certs)\n\n- macro:
    chef_client_writing_conf\n  condition: (proc.pcmdline startswith \"chef-client
    /opt/gitlab\" and fd.name startswith /etc/gitlab)\n\n- macro: centrify_writing_krb\n
    \ condition: (proc.name in (adjoin,addns) and fd.name startswith /etc/krb5)\n\n-
    macro: sssd_writing_krb\n  condition: (proc.name=adcli and proc.aname[2]=sssd
    and fd.name startswith /etc/krb5)\n\n- macro: cockpit_writing_conf\n  condition:
    >\n    ((proc.pname=cockpit-kube-la or proc.aname[2]=cockpit-kube-la)\n     and
    fd.name startswith /etc/cockpit)\n\n- macro: ipsec_writing_conf\n  condition:
    (proc.name=start-ipsec.sh and fd.directory=/etc/ipsec)\n\n- macro: exe_running_docker_save\n
    \ condition: >\n    (proc.name = \"exe\"\n    and (proc.cmdline contains \"/var/lib/docker\"\n
    \   or proc.cmdline contains \"/var/run/docker\")\n    and proc.pname in (dockerd,
    docker, dockerd-current, docker-current))\n\n# Ideally we'd have a length check
    here as well but\n# filterchecks don't have operators like len()\n- macro: sed_temporary_file\n
    \ condition: (proc.name=sed and fd.name startswith \"/etc/sed\")\n\n- macro: python_running_get_pip\n
    \ condition: (proc.cmdline startswith \"python get-pip.py\")\n\n- macro: python_running_ms_oms\n
    \ condition: (proc.cmdline startswith \"python /var/lib/waagent/\")\n\n- macro:
    gugent_writing_guestagent_log\n  condition: (proc.name=gugent and fd.name=GuestAgent.log)\n\n-
    macro: dse_writing_tmp\n  condition: (proc.name=dse-entrypoint and fd.name=/root/tmp__)\n\n-
    macro: zap_writing_state\n  condition: (proc.exe endswith java and proc.cmdline
    contains \"jar /zap\" and fd.name startswith /root/.ZAP)\n\n- macro: airflow_writing_state\n
    \ condition: (proc.name=airflow and fd.name startswith /root/airflow)\n\n- macro:
    rpm_writing_root_rpmdb\n  condition: (proc.name=rpm and fd.directory=/root/.rpmdb)\n\n-
    macro: maven_writing_groovy\n  condition: (proc.exe endswith java and proc.cmdline
    contains \"classpath /usr/local/apache-maven\" and fd.name startswith /root/.groovy)\n\n-
    macro: chef_writing_conf\n  condition: (proc.name=chef-client and fd.name startswith
    /root/.chef)\n\n- macro: kubectl_writing_state\n  condition: (proc.name in (kubectl,oc)
    and fd.name startswith /root/.kube)\n\n- macro: java_running_cassandra\n  condition:
    (proc.exe endswith java and proc.cmdline contains \"cassandra.jar\")\n\n- macro:
    cassandra_writing_state\n  condition: (java_running_cassandra and fd.directory=/root/.cassandra)\n\n#
    Istio\n- macro: galley_writing_state\n  condition: (proc.name=galley and fd.name
    in (known_istio_files))\n\n- list: known_istio_files\n  items: [/healthready,
    /healthliveness]\n\n- macro: calico_writing_state\n  condition: (proc.name=kube-controller
    and fd.name startswith /status.json and k8s.pod.name startswith calico)\n\n- macro:
    calico_writing_envvars\n  condition: (proc.name=start_runit and fd.name startswith
    \"/etc/envvars\" and container.image.repository endswith \"calico/node\")\n\n-
    list: repository_files\n  items: [sources.list]\n\n- list: repository_directories\n
    \ items: [/etc/apt/sources.list.d, /etc/yum.repos.d, /etc/apt]\n\n- macro: access_repositories\n
    \ condition: (fd.directory in (repository_directories) or\n              (fd.name
    pmatch (repository_directories) and\n               fd.filename in (repository_files)))\n\n-
    macro: modify_repositories\n  condition: (evt.arg.newpath pmatch (repository_directories))\n\n-
    macro: user_known_update_package_registry\n  condition: (never_true)\n\n- rule:
    Update Package Repository\n  desc: > \n    This rule generically detects updates
    to package repositories and can be seen as an auditing measure. \n    Recommend
    evaluating its relevance for your specific environment.\n  condition: >\n    ((open_write
    and access_repositories) or (modify and modify_repositories))\n    and not package_mgmt_procs\n
    \   and not package_mgmt_ancestor_procs\n    and not exe_running_docker_save\n
    \   and not user_known_update_package_registry\n  output: Repository files get
    updated (newpath=%evt.arg.newpath file=%fd.name pcmdline=%proc.pcmdline evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority:\n    NOTICE\n  tags: [maturity_sandbox,
    host, container, filesystem, mitre_execution, T1072]\n\n# Users should overwrite
    this macro to specify conditions under which a\n# write under the binary dir is
    ignored. For example, it may be okay to\n# install a binary in the context of
    a ci/cd build.\n- macro: user_known_write_below_binary_dir_activities\n  condition:
    (never_true)\n\n- rule: Write below binary dir\n  desc: > \n    Trying to write
    to any file below specific binary directories can serve as an auditing rule to
    track general system changes. \n    Such rules can be noisy and challenging to
    interpret, particularly if your system frequently undergoes updates. However,
    careful \n    profiling of your environment can transform this rule into an effective
    rule for detecting unusual behavior associated with system \n    changes, including
    compliance-related cases.\n  condition: >\n    open_write and evt.dir=< \n    and
    bin_dir\n    and not package_mgmt_procs\n    and not exe_running_docker_save\n
    \   and not python_running_get_pip\n    and not python_running_ms_oms\n    and
    not user_known_write_below_binary_dir_activities\n  output: File below a known
    binary directory opened for writing (file=%fd.name pcmdline=%proc.pcmdline gparent=%proc.aname[2]
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, host, container, filesystem, mitre_persistence, T1543]\n\n#
    If you'd like to generally monitor a wider set of directories on top\n# of the
    ones covered by the rule Write below binary dir, you can use\n# the following
    rule and lists.\n- list: monitored_directories\n  items: [/boot, /lib, /lib64,
    /usr/lib, /usr/local/lib, /usr/local/sbin, /usr/local/bin, /root/.ssh]\n\n- macro:
    user_ssh_directory\n  condition: (fd.name contains '/.ssh/' and fd.name glob '/home/*/.ssh/*')\n\n#
    google_accounts_(daemon)\n- macro: google_accounts_daemon_writing_ssh\n  condition:
    (proc.name=google_accounts and user_ssh_directory)\n\n- macro: cloud_init_writing_ssh\n
    \ condition: (proc.name=cloud-init and user_ssh_directory)\n\n- macro: mkinitramfs_writing_boot\n
    \ condition: (proc.pname in (mkinitramfs, update-initramf) and fd.directory=/boot)\n\n-
    macro: monitored_dir\n  condition: >\n    (fd.directory in (monitored_directories)\n
    \    or user_ssh_directory)\n    and not mkinitramfs_writing_boot\n\n# Add conditions
    to this macro (probably in a separate file,\n# overwriting this macro) to allow
    for specific combinations of\n# programs writing below monitored directories.\n#\n#
    Its default value is an expression that always is false, which\n# becomes true
    when the \"not ...\" in the rule is applied.\n- macro: user_known_write_monitored_dir_conditions\n
    \ condition: (never_true)\n\n- rule: Write below monitored dir\n  desc: > \n    Trying
    to write to any file below a set of monitored directories can serve as an auditing
    rule to track general system changes. \n    Such rules can be noisy and challenging
    to interpret, particularly if your system frequently undergoes updates. However,
    careful \n    profiling of your environment can transform this rule into an effective
    rule for detecting unusual behavior associated with system \n    changes, including
    compliance-related cases.\n  condition: >\n    open_write and evt.dir=<\n    and
    monitored_dir\n    and not package_mgmt_procs\n    and not coreos_write_ssh_dir\n
    \   and not exe_running_docker_save\n    and not python_running_get_pip\n    and
    not python_running_ms_oms\n    and not google_accounts_daemon_writing_ssh\n    and
    not cloud_init_writing_ssh\n    and not user_known_write_monitored_dir_conditions\n
    \ output: File below a monitored directory opened for writing (file=%fd.name pcmdline=%proc.pcmdline
    gparent=%proc.aname[2] evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, host, container, filesystem, mitre_persistence, T1543]\n\n-
    list: safe_etc_dirs\n  items: [/etc/cassandra, /etc/ssl/certs/java, /etc/logstash,
    /etc/nginx/conf.d, /etc/container_environment, /etc/hrmconfig, /etc/fluent/configs.d.
    /etc/alertmanager]\n\n- macro: fluentd_writing_conf_files\n  condition: (proc.name=start-fluentd
    and fd.name in (/etc/fluent/fluent.conf, /etc/td-agent/td-agent.conf))\n\n- macro:
    qualys_writing_conf_files\n  condition: (proc.name=qualys-cloud-ag and fd.name=/etc/qualys/cloud-agent/qagent-log.conf)\n\n-
    macro: git_writing_nssdb\n  condition: (proc.name=git-remote-http and fd.directory=/etc/pki/nssdb)\n\n-
    macro: plesk_writing_keys\n  condition: (proc.name in (plesk_binaries) and fd.name
    startswith /etc/sw/keys)\n\n- macro: plesk_install_writing_apache_conf\n  condition:
    (proc.cmdline startswith \"bash -hB /usr/lib/plesk-9.0/services/webserver.apache
    configure\"\n              and fd.name=\"/etc/apache2/apache2.conf.tmp\")\n\n-
    macro: plesk_running_mktemp\n  condition: (proc.name=mktemp and proc.aname[3]
    in (plesk_binaries))\n\n- macro: networkmanager_writing_resolv_conf\n  condition:
    (proc.aname[2]=nm-dispatcher and fd.name=/etc/resolv.conf)\n\n- macro: add_shell_writing_shells_tmp\n
    \ condition: (proc.name=add-shell and fd.name=/etc/shells.tmp)\n\n- macro: duply_writing_exclude_files\n
    \ condition: (proc.name=touch and proc.pcmdline startswith \"bash /usr/bin/duply\"
    and fd.name startswith \"/etc/duply\")\n\n- macro: xmlcatalog_writing_files\n
    \ condition: (proc.name=update-xmlcatal and fd.directory=/etc/xml)\n\n- macro:
    datadog_writing_conf\n  condition: ((proc.cmdline startswith \"python /opt/datadog-agent\"
    or\n               proc.cmdline startswith \"entrypoint.sh /entrypoint.sh datadog
    start\" or\n               proc.cmdline startswith \"agent.py /opt/datadog-agent\")\n
    \             and fd.name startswith \"/etc/dd-agent\")\n\n- macro: rancher_writing_conf\n
    \ condition: ((proc.name in (healthcheck, lb-controller, rancher-dns)) and\n              (container.image.repository
    contains \"rancher/healthcheck\" or\n               container.image.repository
    contains \"rancher/lb-service-haproxy\" or\n               container.image.repository
    contains \"rancher/dns\") and\n              (fd.name startswith \"/etc/haproxy\"
    or fd.name startswith \"/etc/rancher-dns\"))\n\n- macro: rancher_writing_root\n
    \ condition: (proc.name=rancher-metadat and\n              (container.image.repository
    contains \"rancher/metadata\" or container.image.repository contains \"rancher/lb-service-haproxy\")
    and\n              fd.name startswith \"/answers.json\")\n\n- macro: checkpoint_writing_state\n
    \ condition: (proc.name=checkpoint and\n              container.image.repository
    contains \"coreos/pod-checkpointer\" and\n              fd.name startswith \"/etc/kubernetes\")\n\n-
    macro: jboss_in_container_writing_passwd\n  condition: >\n    ((proc.cmdline=\"run-java.sh
    /opt/jboss/container/java/run/run-java.sh\"\n      or proc.cmdline=\"run-java.sh
    /opt/run-java/run-java.sh\")\n     and container\n     and fd.name=/etc/passwd)\n\n-
    macro: curl_writing_pki_db\n  condition: (proc.name=curl and fd.directory=/etc/pki/nssdb)\n\n-
    macro: haproxy_writing_conf\n  condition: ((proc.name in (update-haproxy-,haproxy_reload.)
    or proc.pname in (update-haproxy-,haproxy_reload,haproxy_reload.))\n               and
    (fd.name=/etc/openvpn/client.map or fd.name startswith /etc/haproxy))\n\n- macro:
    java_writing_conf\n  condition: (proc.exe endswith java and fd.name=/etc/.java/.systemPrefs/.system.lock)\n\n-
    macro: rabbitmq_writing_conf\n  condition: (proc.name=rabbitmq-server and fd.directory=/etc/rabbitmq)\n\n-
    macro: rook_writing_conf\n  condition: (proc.name=toolbox.sh and container.image.repository=rook/toolbox\n
    \             and fd.directory=/etc/ceph)\n\n- macro: httpd_writing_conf_logs\n
    \ condition: (proc.name=httpd and fd.name startswith /etc/httpd/)\n\n- macro:
    mysql_writing_conf\n  condition: >\n    ((proc.name in (start-mysql.sh, run-mysqld)
    or proc.pname=start-mysql.sh) and\n     (fd.name startswith /etc/mysql or fd.directory=/etc/my.cnf.d))\n\n-
    macro: redis_writing_conf\n  condition: >\n    (proc.name in (run-redis, redis-launcher.)
    and (fd.name=/etc/redis.conf or fd.name startswith /etc/redis))\n\n- macro: openvpn_writing_conf\n
    \ condition: (proc.name in (openvpn,openvpn-entrypo) and fd.name startswith /etc/openvpn)\n\n-
    macro: php_handlers_writing_conf\n  condition: (proc.name=php_handlers_co and
    fd.name=/etc/psa/php_versions.json)\n\n- macro: sed_writing_temp_file\n  condition:
    >\n    ((proc.aname[3]=cron_start.sh and fd.name startswith /etc/security/sed)
    or\n     (proc.name=sed and (fd.name startswith /etc/apt/sources.list.d/sed or\n
    \                        fd.name startswith /etc/apt/sed or\n                         fd.name
    startswith /etc/apt/apt.conf.d/sed)))\n\n- macro: cron_start_writing_pam_env\n
    \ condition: (proc.cmdline=\"bash /usr/sbin/start-cron\" and fd.name=/etc/security/pam_env.conf)\n\n#
    In some cases dpkg-reconfigur runs commands that modify /etc. Not\n# putting the
    full set of package management programs yet.\n- macro: dpkg_scripting\n  condition:
    (proc.aname[2] in (dpkg-reconfigur, dpkg-preconfigu))\n\n- macro: ufw_writing_conf\n
    \ condition: (proc.name=ufw and fd.directory=/etc/ufw)\n\n- macro: calico_writing_conf\n
    \ condition: >\n    (((proc.name = calico-node) or\n      (container.image.repository=gcr.io/projectcalico-org/node
    and proc.name in (start_runit, cp)) or\n      (container.image.repository=gcr.io/projectcalico-org/cni
    and proc.name=sed))\n     and fd.name startswith /etc/calico)\n\n- macro: prometheus_conf_writing_conf\n
    \ condition: (proc.name=prometheus-conf and fd.name startswith /etc/prometheus/config_out)\n\n-
    macro: openshift_writing_conf\n  condition: (proc.name=oc and fd.name startswith
    /etc/origin/node)\n\n- macro: keepalived_writing_conf\n  condition: (proc.name
    in (keepalived, kube-keepalived) and fd.name=/etc/keepalived/keepalived.conf)\n\n-
    macro: etcd_manager_updating_dns\n  condition: (container and proc.name=etcd-manager
    and fd.name=/etc/hosts)\n\n- macro: automount_using_mtab\n  condition: (proc.pname
    = automount and fd.name startswith /etc/mtab)\n\n- macro: mcafee_writing_cma_d\n
    \ condition: (proc.name=macompatsvc and fd.directory=/etc/cma.d)\n\n- macro: avinetworks_supervisor_writing_ssh\n
    \ condition: >\n    (proc.cmdline=\"se_supervisor.p /opt/avi/scripts/se_supervisor.py
    -d\" and\n      (fd.name startswith /etc/ssh/known_host_ or\n       fd.name startswith
    /etc/ssh/ssh_monitor_config_ or\n       fd.name startswith /etc/ssh/ssh_config_))\n\n-
    macro: multipath_writing_conf\n  condition: (proc.name = multipath and fd.name
    startswith /etc/multipath/)\n\n# Add conditions to this macro (probably in a separate
    file,\n# overwriting this macro) to allow for specific combinations of\n# programs
    writing below specific directories below\n# /etc. fluentd_writing_conf_files is
    a good example to follow, as it\n# specifies both the program doing the writing
    as well as the specific\n# files it is allowed to modify.\n#\n# In this file,
    it just takes one of the programs in the base macro\n# and repeats it.\n- macro:
    user_known_write_etc_conditions\n  condition: (proc.name=confd)\n\n# This is a
    placeholder for user to extend the whitelist for write below etc rule\n- macro:
    user_known_write_below_etc_activities\n  condition: (never_true)\n\n- macro: calico_node\n
    \ condition: (container.image.repository endswith calico/node and proc.name=calico-node)\n\n-
    macro: write_etc_common\n  condition: >\n    (open_write \n    and etc_dir and
    evt.dir=< \n    and proc_name_exists\n    and not proc.name in (passwd_binaries,
    shadowutils_binaries, sysdigcloud_binaries,\n                          package_mgmt_binaries,
    ssl_mgmt_binaries, dhcp_binaries,\n                          dev_creation_binaries,
    shell_mgmt_binaries,\n                          mail_config_binaries,\n                          sshkit_script_binaries,\n
    \                         ldconfig.real, ldconfig, confd, gpg, insserv,\n                          apparmor_parser,
    update-mime, tzdata.config, tzdata.postinst,\n                          systemd,
    systemd-machine, systemd-sysuser,\n                          debconf-show, rollerd,
    bind9.postinst, sv,\n                          gen_resolvconf., update-ca-certi,
    certbot, runsv,\n                          qualys-cloud-ag, locales.postins, nomachine_binaries,\n
    \                         adclient, certutil, crlutil, pam-auth-update, parallels_insta,\n
    \                         openshift-launc, update-rc.d, puppet, falcoctl)\n    and
    not (container and proc.cmdline in (\"cp /run/secrets/kubernetes.io/serviceaccount/ca.crt
    /etc/pki/ca-trust/source/anchors/openshift-ca.crt\"))\n    and not proc.pname
    in (sysdigcloud_binaries, mail_config_binaries, hddtemp.postins, sshkit_script_binaries,
    locales.postins, deb_binaries, dhcp_binaries)\n    and not fd.name pmatch (safe_etc_dirs)\n
    \   and not fd.name in (/etc/container_environment.sh, /etc/container_environment.json,
    /etc/motd, /etc/motd.svc)\n    and not sed_temporary_file\n    and not exe_running_docker_save\n
    \   and not ansible_running_python\n    and not python_running_denyhosts\n    and
    not fluentd_writing_conf_files\n    and not user_known_write_etc_conditions\n
    \   and not run_by_centrify\n    and not run_by_adclient\n    and not qualys_writing_conf_files\n
    \   and not git_writing_nssdb\n    and not plesk_writing_keys\n    and not plesk_install_writing_apache_conf\n
    \   and not plesk_running_mktemp\n    and not networkmanager_writing_resolv_conf\n
    \   and not run_by_chef\n    and not add_shell_writing_shells_tmp\n    and not
    duply_writing_exclude_files\n    and not xmlcatalog_writing_files\n    and not
    parent_supervise_running_multilog\n    and not supervise_writing_status\n    and
    not pki_realm_writing_realms\n    and not htpasswd_writing_passwd\n    and not
    lvprogs_writing_conf\n    and not ovsdb_writing_openvswitch\n    and not datadog_writing_conf\n
    \   and not curl_writing_pki_db\n    and not haproxy_writing_conf\n    and not
    java_writing_conf\n    and not dpkg_scripting\n    and not parent_ucf_writing_conf\n
    \   and not rabbitmq_writing_conf\n    and not rook_writing_conf\n    and not
    php_handlers_writing_conf\n    and not sed_writing_temp_file\n    and not cron_start_writing_pam_env\n
    \   and not httpd_writing_conf_logs\n    and not mysql_writing_conf\n    and not
    openvpn_writing_conf\n    and not consul_template_writing_conf\n    and not countly_writing_nginx_conf\n
    \   and not ms_oms_writing_conf\n    and not ms_scx_writing_conf\n    and not
    azure_scripts_writing_conf\n    and not azure_networkwatcher_writing_conf\n    and
    not couchdb_writing_conf\n    and not update_texmf_writing_conf\n    and not slapadd_writing_conf\n
    \   and not symantec_writing_conf\n    and not liveupdate_writing_conf\n    and
    not sosreport_writing_files\n    and not selinux_writing_conf\n    and not veritas_writing_config\n
    \   and not nginx_writing_conf\n    and not nginx_writing_certs\n    and not chef_client_writing_conf\n
    \   and not centrify_writing_krb\n    and not sssd_writing_krb\n    and not cockpit_writing_conf\n
    \   and not ipsec_writing_conf\n    and not httpd_writing_ssl_conf\n    and not
    userhelper_writing_etc_security\n    and not pkgmgmt_progs_writing_pki\n    and
    not update_ca_trust_writing_pki\n    and not brandbot_writing_os_release\n    and
    not redis_writing_conf\n    and not openldap_writing_conf\n    and not ucpagent_writing_conf\n
    \   and not iscsi_writing_conf\n    and not istio_writing_conf\n    and not ufw_writing_conf\n
    \   and not calico_writing_conf\n    and not calico_writing_envvars\n    and not
    prometheus_conf_writing_conf\n    and not openshift_writing_conf\n    and not
    keepalived_writing_conf\n    and not rancher_writing_conf\n    and not checkpoint_writing_state\n
    \   and not jboss_in_container_writing_passwd\n    and not etcd_manager_updating_dns\n
    \   and not user_known_write_below_etc_activities\n    and not automount_using_mtab\n
    \   and not mcafee_writing_cma_d\n    and not avinetworks_supervisor_writing_ssh\n
    \   and not multipath_writing_conf\n    and not calico_node)\n\n- rule: Write
    below etc\n  desc: > \n    Trying to write to any file below /etc can serve as
    an auditing rule to track general system changes. \n    Such rules can be noisy
    and challenging to interpret, particularly if your system frequently undergoes
    updates. However, careful \n    profiling of your environment can transform this
    rule into an effective rule for detecting unusual behavior associated with system
    \n    changes, including compliance-related cases.\n  condition: write_etc_common\n
    \ output: File below /etc opened for writing (file=%fd.name pcmdline=%proc.pcmdline
    gparent=%proc.aname[2] ggparent=%proc.aname[3] gggparent=%proc.aname[4] evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n  tags: [maturity_sandbox,
    host, container, filesystem, mitre_persistence, T1098]\n\n- list: known_root_files\n
    \ items: [/root/.monit.state, /root/.auth_tokens, /root/.bash_history, /root/.ash_history,
    /root/.aws/credentials,\n          /root/.viminfo.tmp, /root/.lesshst, /root/.bzr.log,
    /root/.gitconfig.lock, /root/.babel.json, /root/.localstack,\n          /root/.node_repl_history,
    /root/.mongorc.js, /root/.dbshell, /root/.augeas/history, /root/.rnd, /root/.wget-hsts,
    /health, /exec.fifo]\n\n- list: known_root_directories\n  items: [/root/.oracle_jre_usage,
    /root/.ssh, /root/.subversion, /root/.nami]\n\n- macro: known_root_conditions\n
    \ condition: (fd.name startswith /root/orcexec.\n              or fd.name startswith
    /root/.m2\n              or fd.name startswith /root/.npm\n              or fd.name
    startswith /root/.pki\n              or fd.name startswith /root/.ivy2\n              or
    fd.name startswith /root/.config/Cypress\n              or fd.name startswith
    /root/.config/pulse\n              or fd.name startswith /root/.config/configstore\n
    \             or fd.name startswith /root/jenkins/workspace\n              or
    fd.name startswith /root/.jenkins\n              or fd.name startswith /root/.cache\n
    \             or fd.name startswith /root/.sbt\n              or fd.name startswith
    /root/.java\n              or fd.name startswith /root/.glide\n              or
    fd.name startswith /root/.sonar\n              or fd.name startswith /root/.v8flag\n
    \             or fd.name startswith /root/infaagent\n              or fd.name
    startswith /root/.local/lib/python\n              or fd.name startswith /root/.pm2\n
    \             or fd.name startswith /root/.gnupg\n              or fd.name startswith
    /root/.pgpass\n              or fd.name startswith /root/.theano\n              or
    fd.name startswith /root/.gradle\n              or fd.name startswith /root/.android\n
    \             or fd.name startswith /root/.ansible\n              or fd.name startswith
    /root/.crashlytics\n              or fd.name startswith /root/.dbus\n              or
    fd.name startswith /root/.composer\n              or fd.name startswith /root/.gconf\n
    \             or fd.name startswith /root/.nv\n              or fd.name startswith
    /root/.local/share/jupyter\n              or fd.name startswith /root/oradiag_root\n
    \             or fd.name startswith /root/workspace\n              or fd.name
    startswith /root/jvm\n              or fd.name startswith /root/.node-gyp)\n\n#
    Add conditions to this macro (probably in a separate file,\n# overwriting this
    macro) to allow for specific combinations of\n# programs writing below specific
    directories below\n# / or /root.\n#\n# In this file, it just takes one of the
    condition in the base macro\n# and repeats it.\n- macro: user_known_write_root_conditions\n
    \ condition: (fd.name=/root/.bash_history)\n\n# This is a placeholder for user
    to extend the whitelist for write below root rule\n- macro: user_known_write_below_root_activities\n
    \ condition: (never_true)\n\n- macro: runc_writing_exec_fifo\n  condition: (proc.cmdline=\"runc:[1:CHILD]
    init\" and fd.name=/exec.fifo)\n\n- macro: runc_writing_var_lib_docker\n  condition:
    (proc.cmdline=\"runc:[1:CHILD] init\" and evt.arg.filename startswith /var/lib/docker)\n\n-
    macro: mysqlsh_writing_state\n  condition: (proc.name=mysqlsh and fd.directory=/root/.mysqlsh)\n\n-
    rule: Write below root\n  desc: > \n    Trying to write to any file directly below
    / or /root can serve as an auditing rule to track general system changes. \n    Such
    rules can be noisy and challenging to interpret, particularly if your system frequently
    undergoes updates. However, careful \n    profiling of your environment can transform
    this rule into an effective rule for detecting unusual behavior associated with
    system \n    changes, including compliance-related cases. Lastly, this rule stands
    out as potentially the noisiest one among rules related \n    to \"write below.\n
    \ condition: >\n    open_write and evt.dir=<\n    and root_dir\n    and proc_name_exists\n
    \   and not fd.name in (known_root_files)\n    and not fd.directory pmatch (known_root_directories)\n
    \   and not exe_running_docker_save\n    and not gugent_writing_guestagent_log\n
    \   and not dse_writing_tmp\n    and not zap_writing_state\n    and not airflow_writing_state\n
    \   and not rpm_writing_root_rpmdb\n    and not maven_writing_groovy\n    and
    not chef_writing_conf\n    and not kubectl_writing_state\n    and not cassandra_writing_state\n
    \   and not galley_writing_state\n    and not calico_writing_state\n    and not
    rancher_writing_root\n    and not runc_writing_exec_fifo\n    and not mysqlsh_writing_state\n
    \   and not known_root_conditions\n    and not user_known_write_root_conditions\n
    \   and not user_known_write_below_root_activities\n  output: File below / or
    /root opened for writing (file=%fd.name evt_type=%evt.type user=%user.name user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: ERROR\n  tags: [maturity_sandbox, host, container, filesystem, mitre_persistence,
    TA0003]\n\n- macro: amazon_linux_running_python_yum\n  condition: >\n    (proc.name
    = python and\n     proc.pcmdline = \"python -m amazon_linux_extras system_motd\"
    and\n     proc.cmdline startswith \"python -c import yum;\")\n\n- macro: user_known_write_rpm_database_activities\n
    \ condition: (never_true)\n\n# Only let rpm-related programs write to the rpm
    database\n- rule: Write below rpm database\n  desc: > \n    Trying to write to
    the rpm database by any non-rpm related program can serve as an auditing rule
    to track general system changes. \n    Such rules can be noisy and challenging
    to interpret, particularly if your system frequently undergoes updates. However,
    careful \n    profiling of your environment can transform this rule into an effective
    rule for detecting unusual behavior associated with system \n    changes, including
    compliance-related cases.\n  condition: >\n    open_write\n    and fd.name startswith
    /var/lib/rpm\n    and not rpm_procs\n    and not ansible_running_python\n    and
    not python_running_chef\n    and not exe_running_docker_save\n    and not amazon_linux_running_python_yum\n
    \   and not user_known_write_rpm_database_activities\n  output: rpm database opened
    for writing by a non-rpm program (file=%fd.name pcmdline=%proc.pcmdline evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n  tags: [maturity_sandbox,
    host, container, filesystem, software_mgmt, mitre_persistence, T1072]\n\n- macro:
    user_known_modify_bin_dir_activities\n  condition: (never_true)\n\n- rule: Modify
    binary dirs\n  desc: > \n    Trying to modify any file below a set of binary directories
    can serve as an auditing rule to track general system changes. \n    Such rules
    can be noisy and challenging to interpret, particularly if your system frequently
    undergoes updates. However, careful \n    profiling of your environment can transform
    this rule into an effective rule for detecting unusual behavior associated with
    system \n    changes, including compliance-related cases.\n  condition: > \n    modify
    \n    and bin_dir_rename\n    and not package_mgmt_procs \n    and not exe_running_docker_save
    \n    and not user_known_modify_bin_dir_activities\n  output: File below known
    binary directory renamed/removed (file=%fd.name pcmdline=%proc.pcmdline evt_args=%evt.args
    evt_type=%evt.type evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, host, container, filesystem, mitre_defense_evasion,
    T1222.002]\n\n- macro: user_known_mkdir_bin_dir_activities\n  condition: (never_true)\n\n-
    rule: Mkdir binary dirs\n  desc: >\n    Trying to create a directory below a set
    of binary directories can serve as an auditing rule to track general system changes.
    \n    Such rules can be noisy and challenging to interpret, particularly if your
    system frequently undergoes updates. However, careful \n    profiling of your
    environment can transform this rule into an effective rule for detecting unusual
    behavior associated with system \n    changes, including compliance-related cases.\n
    \ condition: >\n    mkdir\n    and bin_dir_mkdir\n    and not package_mgmt_procs\n
    \   and not user_known_mkdir_bin_dir_activities\n    and not exe_running_docker_save\n
    \ output: Directory below known binary directory created (directory=%evt.arg.path
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, host, container, filesystem, mitre_persistence, T1222.002]\n\n#
    https://docs.aws.amazon.com/eks/latest/userguide/add-ons-images.html\n#  official
    AWS EKS registry list. AWS has different ECR repo per region\n- macro: allowed_aws_ecr_registry_root_for_eks\n
    \ condition: >\n    (container.image.repository startswith \"602401143452.dkr.ecr\"
    or\n     container.image.repository startswith \"877085696533.dkr.ecr\" or\n     container.image.repository
    startswith \"800184023465.dkr.ecr\" or\n     container.image.repository startswith
    \"918309763551.dkr.ecr\" or\n     container.image.repository startswith \"961992271922.dkr.ecr\"
    or\n     container.image.repository startswith \"590381155156.dkr.ecr\" or\n     container.image.repository
    startswith \"558608220178.dkr.ecr\" or\n     container.image.repository startswith
    \"151742754352.dkr.ecr\" or\n     container.image.repository startswith \"013241004608.dkr.ecr\")\n\n-
    macro: aws_eks_image_sensitive_mount\n  condition: >\n    (allowed_aws_ecr_registry_root_for_eks
    and container.image.repository endswith \".amazonaws.com/amazon-k8s-cni\")\n\n#
    These images are allowed both to run with --privileged and to mount\n# sensitive
    paths from the host filesystem.\n#\n# NOTE: This list is only provided for backwards
    compatibility with\n# older local falco rules files that may have been appending
    to\n# trusted_images. To make customizations, it's better to add images to\n#
    either privileged_images or falco_sensitive_mount_images.\n- list: trusted_images\n
    \ items: []\n\n# Add conditions to this macro (probably in a separate file,\n#
    overwriting this macro) to specify additional containers that are\n# trusted and
    therefore allowed to run privileged *and* with sensitive\n# mounts.\n#\n# Like
    trusted_images, this is deprecated in favor of\n# user_privileged_containers and
    user_sensitive_mount_containers and\n# is only provided for backwards compatibility.\n#\n#
    In this file, it just takes one of the images in trusted_containers\n# and repeats
    it.\n- macro: user_trusted_containers\n  condition: (never_true)\n\n# Falco containers\n-
    list: falco_containers\n  items:\n    - falcosecurity/falco\n    - docker.io/falcosecurity/falco\n
    \   - public.ecr.aws/falcosecurity/falco\n\n# Falco no driver containers\n    -
    falcosecurity/falco-no-driver\n    - docker.io/falcosecurity/falco-no-driver\n
    \   - public.ecr.aws/falcosecurity/falco-no-driver\n\n# These container images
    are allowed to mount sensitive paths from the\n# host filesystem.\n- list: falco_sensitive_mount_images\n
    \ items: [\n    falco_containers,\n    docker.io/sysdig/sysdig, sysdig/sysdig,\n
    \   gcr.io/google_containers/hyperkube,\n    gcr.io/google_containers/kube-proxy,
    docker.io/calico/node,\n    docker.io/rook/toolbox, docker.io/cloudnativelabs/kube-router,
    docker.io/consul,\n    docker.io/datadog/docker-dd-agent, docker.io/datadog/agent,
    docker.io/docker/ucp-agent, docker.io/gliderlabs/logspout,\n    docker.io/netdata/netdata,
    docker.io/google/cadvisor, docker.io/prom/node-exporter,\n    amazon/amazon-ecs-agent,
    prom/node-exporter, amazon/cloudwatch-agent\n    ]\n\n- macro: falco_sensitive_mount_containers\n
    \ condition: (user_trusted_containers or\n              aws_eks_image_sensitive_mount
    or\n              container.image.repository in (trusted_images) or\n              container.image.repository
    in (falco_sensitive_mount_images) or\n              container.image.repository
    startswith quay.io/sysdig/ or\n              container.image.repository=k8scloudprovider/cinder-csi-plugin)\n\n#
    Add conditions to this macro (probably in a separate file,\n# overwriting this
    macro) to specify additional containers that are\n# allowed to perform sensitive
    mounts.\n#\n# In this file, it just takes one of the images in falco_sensitive_mount_images\n#
    and repeats it.\n- macro: user_sensitive_mount_containers\n  condition: (never_true)\n\n#
    For now, only considering a full mount of /etc as\n# sensitive. Ideally, this
    would also consider all subdirectories\n# below /etc as well, but the globbing
    mechanism\n# doesn't allow exclusions of a full pattern, only single characters.\n-
    macro: sensitive_mount\n  condition: (container.mount.dest[/proc*] != \"N/A\"
    or\n              container.mount.dest[/var/run/docker.sock] != \"N/A\" or\n              container.mount.dest[/var/run/crio/crio.sock]
    != \"N/A\" or\n              container.mount.dest[/run/containerd/containerd.sock]
    != \"N/A\" or\n              container.mount.dest[/var/lib/kubelet] != \"N/A\"
    or\n              container.mount.dest[/var/lib/kubelet/pki] != \"N/A\" or\n              container.mount.dest[/]
    != \"N/A\" or\n              container.mount.dest[/home/admin] != \"N/A\" or\n
    \             container.mount.dest[/etc] != \"N/A\" or\n              container.mount.dest[/etc/kubernetes]
    != \"N/A\" or\n              container.mount.dest[/etc/kubernetes/manifests] !=
    \"N/A\" or\n              container.mount.dest[/root*] != \"N/A\")\n\n- rule:
    Launch Sensitive Mount Container\n  desc: >\n    Detect the initial process launched
    within a container that has a mount from a sensitive host directory (e.g. /proc).
    \n    Exceptions are made for known trusted images. This rule holds value for
    generic auditing; however, its noisiness \n    varies based on your environment.\n
    \ condition: >\n    container_started \n    and container\n    and sensitive_mount\n
    \   and not falco_sensitive_mount_containers\n    and not user_sensitive_mount_containers\n
    \ output: Container with sensitive mount started (mounts=%container.mounts evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: INFO\n  tags: [maturity_sandbox,
    container, cis, mitre_execution, T1610]\n\n# In a local/user rules file, you could
    override this macro to\n# explicitly enumerate the container images that you want
    to run in\n# your environment. In this main falco rules file, there isn't any
    way\n# to know all the containers that can run, so any container is\n# allowed,
    by using a filter that is guaranteed to evaluate to true.\n# In the overridden
    macro, the condition would look something like\n# (container.image.repository
    = vendor/container-1 or\n# container.image.repository = vendor/container-2 or
    ...)\n- macro: allowed_containers\n  condition: (container.id exists)\n\n- rule:
    Launch Disallowed Container\n  desc: >\n    Detect the initial process launched
    within a container that is not in a list of allowed containers. \n    This rule
    holds value for generic auditing; however, this rule requires a good understanding
    of your \n    setup and consistent effort to keep the list of allowed containers
    current. In some situations, \n    this can be challenging to manage.\n  condition:
    > \n    container_started \n    and container \n    and not allowed_containers\n
    \ output: Container started and not in allowed list (evt_type=%evt.type user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: WARNING\n  tags: [maturity_sandbox, container, mitre_lateral_movement,
    T1610]\n\n# In some environments, any attempt by a interpreted program (perl,\n#
    python, ruby, etc) to listen for incoming connections or perform\n# outgoing connections
    might be suspicious. These rules are not\n# enabled by default.\n- rule: Interpreted
    procs inbound network activity\n  desc: > \n    Any inbound network activity performed
    by any interpreted program (perl, python, ruby, etc.). While it offers broad coverage
    and behavioral \n    insights, operationalizing it effectively requires significant
    time and might result in a moderate level of noise. Suggesting customizing \n
    \   this rule to be more specific. For example, you could set it up to alert only
    for important namespaces after studying their usual behavior.\n  condition: >\n
    \   inbound \n    and interpreted_procs\n  enabled: false\n  output: Interpreted
    program received/listened for network traffic (connection=%fd.name lport=%fd.lport
    rport=%fd.rport fd_type=%fd.type fd_proto=fd.l4proto evt_type=%evt.type user=%user.name
    user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath
    parent=%proc.pname command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags
    %container.info)\n  priority: NOTICE\n  tags: [maturity_sandbox, host, container,
    network, mitre_exfiltration, TA0011]\n\n- rule: Interpreted procs outbound network
    activity\n  desc: > \n    Any outbound network activity performed by any interpreted
    program (perl, python, ruby, etc.). While it offers broad coverage and behavioral
    \n    insights, operationalizing it effectively requires significant time and
    might result in a moderate level of noise. Suggesting customizing \n    this rule
    to be more specific. For example, you could set it up to alert only for important
    namespaces after studying their usual behavior.\n  condition: >\n    outbound
    \n    and interpreted_procs\n  enabled: false\n  output: Interpreted program performed
    outgoing network connection (connection=%fd.name lport=%fd.lport rport=%fd.rport
    fd_type=%fd.type fd_proto=fd.l4proto evt_type=%evt.type user=%user.name user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: NOTICE\n  tags: [maturity_sandbox, host, container, network, mitre_exfiltration,
    TA0011]\n\n# In a local/user rules file, list the container images that are\n#
    allowed to contact NodePort services from within a container. This\n# might cover
    cases where the K8s infrastructure itself is running\n# within a container.\n#\n#
    By default, all containers are allowed to contact NodePort services.\n- macro:
    nodeport_containers\n  condition: (never_true)\n\n- rule: Unexpected K8s NodePort
    Connection\n  desc: > \n    Detect attempts to utilize K8s NodePorts from a container.
    K8s NodePorts are accessible on the eth0 interface of \n    each node, and they
    facilitate external traffic into a Kubernetes cluster. Attackers could misuse
    them for \n    unauthorized access. The rule uses default port ranges, but check
    for custom ranges and make necessary adjustments. \n    Also, consider tuning
    this rule as needed.\n  condition: > \n    inbound_outbound \n    and container
    \n    and fd.sport >= 30000 \n    and fd.sport <= 32767 \n    and not nodeport_containers\n
    \ enabled: false\n  output: Unexpected K8s NodePort Connection (connection=%fd.name
    lport=%fd.lport rport=%fd.rport fd_type=%fd.type fd_proto=fd.l4proto evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: NOTICE\n  tags: [maturity_sandbox,
    network, k8s, container, mitre_persistence, T1205.001, NIST_800-53_AC-6]\n\n-
    list: exclude_hidden_directories\n  items: [/root/.cassandra]\n\n# The rule is
    disabled by default.\n- macro: user_known_create_hidden_file_activities\n  condition:
    (never_true)\n\n- rule: Create Hidden Files or Directories\n  desc: > \n    Detecting
    hidden files or directories creation can serve as an auditing rule to track general
    system changes. \n    Such rules can be noisy and challenging to interpret, particularly
    if your system frequently undergoes updates. However, careful \n    profiling
    of your environment can transform this rule into an effective rule for detecting
    unusual behavior associated with system \n    changes, including compliance-related
    cases.\n  condition: >\n    ((modify and evt.arg.newpath contains \"/.\") or\n
    \    (mkdir and evt.arg.path contains \"/.\") or\n     (open_write and evt.arg.flags
    contains \"O_CREAT\" and fd.name contains \"/.\" and not fd.name pmatch (exclude_hidden_directories)))
    \n    and not user_known_create_hidden_file_activities\n    and not exe_running_docker_save\n
    \ enabled: false\n  output: Hidden file or directory created (file=%fd.name newpath=%evt.arg.newpath
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority:\n    NOTICE\n
    \ tags: [maturity_sandbox, host, container, filesystem, mitre_defense_evasion,
    T1564.001]\n\n- list: miner_ports\n  items: [\n        25, 3333, 3334, 3335, 3336,
    3357, 4444,\n        5555, 5556, 5588, 5730, 6099, 6666, 7777,\n        7778,
    8000, 8001, 8008, 8080, 8118, 8333,\n        8888, 8899, 9332, 9999, 14433, 14444,\n
    \       45560, 45700\n    ]\n\n- list: miner_domains\n  items: [\n      \"asia1.ethpool.org\",\"ca.minexmr.com\",\n
    \     \"cn.stratum.slushpool.com\",\"de.minexmr.com\",\n      \"eth-ar.dwarfpool.com\",\"eth-asia.dwarfpool.com\",\n
    \     \"eth-asia1.nanopool.org\",\"eth-au.dwarfpool.com\",\n      \"eth-au1.nanopool.org\",\"eth-br.dwarfpool.com\",\n
    \     \"eth-cn.dwarfpool.com\",\"eth-cn2.dwarfpool.com\",\n      \"eth-eu.dwarfpool.com\",\"eth-eu1.nanopool.org\",\n
    \     \"eth-eu2.nanopool.org\",\"eth-hk.dwarfpool.com\",\n      \"eth-jp1.nanopool.org\",\"eth-ru.dwarfpool.com\",\n
    \     \"eth-ru2.dwarfpool.com\",\"eth-sg.dwarfpool.com\",\n      \"eth-us-east1.nanopool.org\",\"eth-us-west1.nanopool.org\",\n
    \     \"eth-us.dwarfpool.com\",\"eth-us2.dwarfpool.com\",\n      \"eu.stratum.slushpool.com\",\"eu1.ethermine.org\",\n
    \     \"eu1.ethpool.org\",\"fr.minexmr.com\",\n      \"mine.moneropool.com\",\"mine.xmrpool.net\",\n
    \     \"pool.minexmr.com\",\"pool.monero.hashvault.pro\",\n      \"pool.supportxmr.com\",\"sg.minexmr.com\",\n
    \     \"sg.stratum.slushpool.com\",\"stratum-eth.antpool.com\",\n      \"stratum-ltc.antpool.com\",\"stratum-zec.antpool.com\",\n
    \     \"stratum.antpool.com\",\"us-east.stratum.slushpool.com\",\n      \"us1.ethermine.org\",\"us1.ethpool.org\",\n
    \     \"us2.ethermine.org\",\"us2.ethpool.org\",\n      \"xmr-asia1.nanopool.org\",\"xmr-au1.nanopool.org\",\n
    \     \"xmr-eu1.nanopool.org\",\"xmr-eu2.nanopool.org\",\n      \"xmr-jp1.nanopool.org\",\"xmr-us-east1.nanopool.org\",\n
    \     \"xmr-us-west1.nanopool.org\",\"xmr.crypto-pool.fr\",\n      \"xmr.pool.minergate.com\",
    \"rx.unmineable.com\",\n      \"ss.antpool.com\",\"dash.antpool.com\",\n      \"eth.antpool.com\",\"zec.antpool.com\",\n
    \     \"xmc.antpool.com\",\"btm.antpool.com\",\n      \"stratum-dash.antpool.com\",\"stratum-xmc.antpool.com\",\n
    \     \"stratum-btm.antpool.com\"\n      ]\n\n- list: https_miner_domains\n  items:
    [\n    \"ca.minexmr.com\",\n    \"cn.stratum.slushpool.com\",\n    \"de.minexmr.com\",\n
    \   \"fr.minexmr.com\",\n    \"mine.moneropool.com\",\n    \"mine.xmrpool.net\",\n
    \   \"pool.minexmr.com\",\n    \"sg.minexmr.com\",\n    \"stratum-eth.antpool.com\",\n
    \   \"stratum-ltc.antpool.com\",\n    \"stratum-zec.antpool.com\",\n    \"stratum.antpool.com\",\n
    \   \"xmr.crypto-pool.fr\",\n    \"ss.antpool.com\",\n    \"stratum-dash.antpool.com\",\n
    \   \"stratum-xmc.antpool.com\",\n    \"stratum-btm.antpool.com\",\n    \"btm.antpool.com\"\n
    \ ]\n\n- list: http_miner_domains\n  items: [\n    \"ca.minexmr.com\",\n    \"de.minexmr.com\",\n
    \   \"fr.minexmr.com\",\n    \"mine.moneropool.com\",\n    \"mine.xmrpool.net\",\n
    \   \"pool.minexmr.com\",\n    \"sg.minexmr.com\",\n    \"xmr.crypto-pool.fr\"\n
    \ ]\n\n# Add rule based on crypto mining IOCs\n- macro: minerpool_https\n  condition:
    (fd.sport=\"443\" and fd.sip.name in (https_miner_domains))\n\n- macro: minerpool_http\n
    \ condition: (fd.sport=\"80\" and fd.sip.name in (http_miner_domains))\n\n- macro:
    minerpool_other\n  condition: (fd.sport in (miner_ports) and fd.sip.name in (miner_domains))\n\n-
    macro: net_miner_pool\n  condition: (evt.type in (sendto, sendmsg, connect) and
    evt.dir=< and (fd.net != \"127.0.0.0/8\" and not fd.snet in (rfc_1918_addresses))
    and ((minerpool_http) or (minerpool_https) or (minerpool_other)))\n\n- macro:
    trusted_images_query_miner_domain_dns\n  condition: (container.image.repository
    in (falco_containers))\n\n# The rule is disabled by default.\n# Note: falco will
    send DNS request to resolve miner pool domain which may trigger alerts in your
    environment.\n- rule: Detect outbound connections to common miner pool ports\n
    \ desc: > \n    Miners usually connect to miner pools using standard ports, and
    this rule flags such activity. Important: Falco currently sends DNS \n    requests
    to resolve miner pool domains, which could trigger other alerts. Prior to enabling
    this rule, it's advised to ensure whether \n    this is acceptable for your environment.
    This rule is specifically disabled for that reason.\n  condition: > \n    net_miner_pool
    \n    and not trusted_images_query_miner_domain_dns\n  enabled: false\n  output:
    Outbound connection to IP/Port flagged by https://cryptoioc.ch (ip=%fd.rip connection=%fd.name
    lport=%fd.lport rport=%fd.rport fd_type=%fd.type fd_proto=fd.l4proto evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n  tags: [maturity_sandbox,
    host, container, network, mitre_impact, T1496]\n\n- rule: Detect crypto miners
    using the Stratum protocol\n  desc: > \n    Miners commonly specify the mining
    pool to connect to using a URI that starts with \"stratum+tcp\". However, this
    rule is highly specific to \n    this technique, and matching command-line arguments
    can generally be bypassed quite easily.\n  condition: > \n    spawned_process
    \n    and (proc.cmdline contains \"stratum+tcp\" or \n         proc.cmdline contains
    \"stratum2+tcp\" or \n         proc.cmdline contains \"stratum+ssl\" or \n         proc.cmdline
    contains \"stratum2+ssl\")\n  output: Possible miner running (evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n  tags: [maturity_sandbox,
    host, container, process, mitre_impact, T1496]\n\n- list: k8s_client_binaries\n
    \ items: [docker, kubectl, crictl]\n\n# TODO: Remove k8s.gcr.io reference after
    01/Dec/2023\n- list: user_known_k8s_ns_kube_system_images\n  items: [\n    k8s.gcr.io/fluentd-gcp-scaler,\n
    \   k8s.gcr.io/node-problem-detector/node-problem-detector,\n    registry.k8s.io/fluentd-gcp-scaler,\n
    \   registry.k8s.io/node-problem-detector/node-problem-detector\n  ]\n\n- list:
    user_known_k8s_images\n  items: [\n    mcr.microsoft.com/aks/hcp/hcp-tunnel-front\n
    \ ]\n\n# Whitelist for known docker client binaries run inside container\n# -
    k8s.gcr.io/fluentd-gcp-scaler / registry.k8s.io/fluentd-gcp-scaler in GCP/GKE\n#
    TODO: Remove k8s.gcr.io reference after 01/Dec/2023\n- macro: user_known_k8s_client_container\n
    \ condition: >\n    (k8s.ns.name=\"kube-system\" and container.image.repository
    in (user_known_k8s_ns_kube_system_images)) or container.image.repository in (user_known_k8s_images)\n\n-
    macro: user_known_k8s_client_container_parens\n  condition: (user_known_k8s_client_container)\n\n-
    rule: Kubernetes Client Tool Launched in Container\n  desc: > \n    Detect the
    execution of a Kubernetes client tool (like docker, kubectl, crictl) within a
    container, which is typically not expected behavior. \n    Although this rule
    targets container workloads, monitoring the use of tools like crictl on the host
    over interactive access could also be \n    valuable for broader auditing objectives.\n
    \ condition: > \n    spawned_process \n    and container \n    and not user_known_k8s_client_container_parens
    \n    and proc.name in (k8s_client_binaries)\n  output: Kubernetes Client Tool
    Launched in Container (evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: WARNING\n
    \ tags: [maturity_sandbox, container, mitre_execution, T1610]\n\n# The two Container
    Drift rules below will fire when a new executable is created in a container.\n#
    There are two ways to create executables - file is created with execution permissions
    or permissions change of existing file.\n# We will use a new filter, is_open_exec,
    to find all files creations with execution permission, and will trace all chmods
    in a container.\n# The use case we are targeting here is an attempt to execute
    code that was not shipped as part of a container (drift) -\n# an activity that
    might be malicious or non-compliant.\n# Two things to pay attention to:\n#   1)
    In most cases, 'docker cp' will not be identified, but the assumption is that
    if an attacker gained access to the container runtime daemon, they are already
    privileged\n#   2) Drift rules will be noisy in environments in which containers
    are built (e.g. docker build)\n# These two rules are not enabled by default.\n-
    macro: user_known_container_drift_activities\n  condition: (never_true)\n\n- rule:
    Container Drift Detected (chmod)\n  desc: > \n    Detect new executables created
    within a container as a result of chmod. While this detection can generate significant
    noise, chmod \n    usage is frequently linked to dropping and executing malicious
    implants. The newer rule \"Drop and execute new binary in container\" \n    provides
    more precise detection of this TTP using unambiguous kernel signals. It is recommended
    to use the new rule. However, this \n    rule might be more relevant for auditing
    if applicable in your environment, such as when chmod is used on files within
    the /tmp folder.\n  condition: >\n    chmod \n    and container \n    and evt.rawres>=0
    \n    and ((evt.arg.mode contains \"S_IXUSR\") or\n         (evt.arg.mode contains
    \"S_IXGRP\") or\n         (evt.arg.mode contains \"S_IXOTH\"))\n    and not runc_writing_exec_fifo
    \n    and not runc_writing_var_lib_docker \n    and not user_known_container_drift_activities
    \n  enabled: false\n  output: Drift detected (chmod), new executable created in
    a container (filename=%evt.arg.filename name=%evt.arg.name mode=%evt.arg.mode
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, container, process, filesystem, mitre_execution, T1059]\n\n#
    ****************************************************************************\n#
    * \"Container Drift Detected (open+create)\" requires FALCO_ENGINE_VERSION 6 *\n#
    ****************************************************************************\n-
    rule: Container Drift Detected (open+create)\n  desc: >\n    Detect new executables
    created within a container as a result of open+create. The newer rule \"Drop and
    execute new binary in container\" \n    provides more precise detection of this
    TTP using unambiguous kernel signals. It is recommended to use the new rule. \n
    \ condition: >\n    evt.type in (open,openat,openat2,creat) \n    and evt.rawres>=0\n
    \   and evt.is_open_exec=true \n    and container \n    and not runc_writing_exec_fifo
    \n    and not runc_writing_var_lib_docker \n    and not user_known_container_drift_activities
    \n  enabled: false\n  output: Drift detected (open+create), new executable created
    in a container (filename=%evt.arg.filename name=%evt.arg.name mode=%evt.arg.mode
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: ERROR\n
    \ tags: [maturity_sandbox, container, process, filesystem, mitre_execution, T1059]\n\n-
    list: run_as_root_image_list\n  items: []\n\n- macro: user_known_run_as_root_container\n
    \ condition: (container.image.repository in (run_as_root_image_list))\n\n# The
    rule is disabled by default and should be enabled when non-root container policy
    has been applied.\n# Note the rule will not work as expected when usernamespace
    is applied, e.g. userns-remap is enabled.\n- rule: Container Run as Root User\n
    \ desc: > \n    Container detected running as the root user. This should be taken
    into account especially when policies disallow containers from running with \n
    \   root user privileges. Note that a root user in containers doesn't inherently
    possess extensive power, as modern container environments define \n    privileges
    through Linux capabilities. To learn more, check out the rule \"Launch Privileged
    Container\".\n  condition: > \n    spawned_process \n    and container \n    and
    proc.vpid=1 \n    and user.uid=0 \n    and not user_known_run_as_root_container\n
    \ enabled: false\n  output: Container launched with root user privilege (evt_type=%evt.type
    user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name
    proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty
    exe_flags=%evt.arg.flags %container.info)\n  priority: INFO\n  tags: [maturity_sandbox,
    container, process, users, mitre_execution, T1610]\n\n# This rule helps detect
    CVE-2021-3156:\n# A privilege escalation to root through heap-based buffer overflow\n-
    rule: Sudo Potential Privilege Escalation\n  desc: > \n    Affecting sudo (<=
    1.9.5p2), there's a privilege escalation vulnerability. By executing sudo using
    the sudoedit -s or sudoedit -i command with a \n    command-line argument that
    ends with a single backslash character, an unprivileged user can potentially escalate
    privileges to root. This rule is \n    highly specific and might be bypassed due
    to potential issues with string matching on command line arguments.\n  condition:
    > \n    spawned_process \n    and user.uid != 0 \n    and (proc.name=sudoedit
    or proc.name = sudo) \n    and (proc.args contains -s or proc.args contains -i
    or proc.args contains --login) \n    and (proc.args contains \"\\ \" or proc.args
    endswith \\)\n  output: Detect Sudo Privilege Escalation Exploit (CVE-2021-3156)
    (evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n
    \ tags: [maturity_sandbox, host, container, filesystem, users, mitre_privilege_escalation,
    T1548.003]\n\n- list: user_known_userfaultfd_processes\n  items: []\n\n- rule:
    Unprivileged Delegation of Page Faults Handling to a Userspace Process\n  desc:
    > \n    Detect a successful unprivileged userfaultfd syscall, which could serve
    as an attack primitive for exploiting other vulnerabilities. \n    To fine-tune
    this rule, consider using the template list \"user_known_userfaultfd_processes\".\n
    \ condition: >\n    evt.type = userfaultfd \n    and user.uid != 0 \n    and (evt.rawres
    >= 0 or evt.res != -1) \n    and not proc.name in (user_known_userfaultfd_processes)\n
    \ output: An userfaultfd syscall was successfully executed by an unprivileged
    user (evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n
    \ tags: [maturity_sandbox, host, container, process, mitre_defense_evasion, TA0005]\n\n#
    This rule helps detect CVE-2021-4034:\n# A privilege escalation to root through
    memory corruption\n- rule: Polkit Local Privilege Escalation Vulnerability (CVE-2021-4034)\n
    \ desc: > \n    This rule detects attempts to exploit a privilege escalation vulnerability
    in Polkit's pkexec. Through the execution of specially \n    crafted code, a local
    user can exploit this weakness to attain root privileges on a compromised system.
    This rule is highly \n    specific in its scope.\n  condition:\n    spawned_process
    \n    and user.uid != 0 \n    and proc.name=pkexec \n    and proc.args = ''\n
    \ output: Detect Polkit pkexec Local Privilege Escalation Exploit (CVE-2021-4034)
    (args=%proc.args evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n
    \ tags: [maturity_sandbox, host, container, process, users, mitre_privilege_escalation,
    TA0004]\n\n# Rule for detecting potential Log4Shell (CVE-2021-44228) exploitation\n#
    Note: Not compatible with Java 17+, which uses read() syscalls\n- macro: java_network_read\n
    \ condition: (evt.type=recvfrom and fd.type in (ipv4, ipv6) and proc.exe endswith
    java)\n\n- rule: Java Process Class File Download\n  desc: > \n    Detecting a
    Java process downloading a class file which could indicate a successful exploit
    of the log4shell Log4j vulnerability (CVE-2021-44228). \n    This rule is highly
    specific in its scope.\n  condition: >\n    java_network_read \n    and evt.buffer
    bcontains cafebabe\n  output: Java process class file download (server_ip=%fd.sip
    server_port=%fd.sport connection=%fd.name lport=%fd.lport rport=%fd.rport fd_type=%fd.type
    fd_proto=fd.l4proto evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: CRITICAL\n
    \ enabled: false\n  tags: [maturity_sandbox, host, container, process, mitre_initial_access,
    T1190]\n\n- list: docker_binaries\n  items: [docker, dockerd, containerd-shim,
    \"runc:[1:CHILD]\", pause, exe, docker-compose, docker-entrypoi, docker-runc-cur,
    docker-current, dockerd-current]\n\n- macro: docker_procs\n  condition: proc.name
    in (docker_binaries)\n\n- rule: Modify Container Entrypoint\n  desc: > \n    This
    rule detect an attempt to write on container entrypoint symlink (/proc/self/exe).
    Possible CVE-2019-5736 Container Breakout exploitation attempt. \n    This rule
    has a more narrow scope.\n  condition: >\n    open_write \n    and container \n
    \   and (fd.name=/proc/self/exe or fd.name startswith /proc/self/fd/) \n    and
    not docker_procs \n    and not proc.cmdline = \"runc:[1:CHILD] init\"\n  enabled:
    false\n  output: Detect Potential Container Breakout Exploit (CVE-2019-5736) (file=%fd.name
    evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: WARNING\n
    \ tags: [maturity_sandbox, container, filesystem, mitre_initial_access, T1611]\n\n-
    list: bpf_profiled_binaries\n  items: [falco, bpftool]\n\n- macro: bpf_profiled_procs\n
    \ condition: (proc.name in (bpf_profiled_binaries))\n\n- rule: BPF Program Not
    Profiled\n  desc: > \n    BPF is a kernel technology that can be misused for malicious
    purposes, like \"Linux Kernel Module Injection\". This \n    rule should be considered
    an auditing rule to notify you of any unprofiled BPF tools running in your environment.
    \n    However, it requires customization after profiling your environment. BPF-powered
    agents make bpf syscalls all the \n    time, so this rule only sends logs for
    BPF_PROG_LOAD calls (bpf cmd=5) in the enter event. If you also want to log \n
    \   whether the syscall failed or succeeded, remove the direction filter and add
    the evt.arg.res_or_fd output field.\n  condition: >\n    evt.type=bpf and evt.dir=>
    \n    and evt.arg.cmd=5\n    and not bpf_profiled_procs\n  output: BPF Program
    Not Profiled (bpf_cmd=%evt.arg.cmd evt_type=%evt.type user=%user.name user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: NOTICE\n  tags: [maturity_sandbox, host, container, mitre_persistence,
    TA0003]\n\n- list: known_decode_payload_containers\n  items: []\n\n- macro: base64_decoding\n
    \ condition: (proc.cmdline contains \"base64\" and (proc.cmdline contains \"--decode\"
    or proc.cmdline contains \"-d\"))\n\n- rule: Decoding Payload in Container\n  desc:
    > \n    Detect any use of {base64} decoding in a container. Legitimate applications
    may decode encoded payloads. The template list \n    known_decode_payload_containers
    can be used for simple tuning and customization, or you can adopt custom, more
    refined tuning. Less \n    sophisticated adversaries may {base64}-decode their
    payloads not only to obfuscate them, but also to ensure that the payload remains
    \n    intact when the application processes it. Note that injecting commands into
    an application's input often results in the application \n    processing passed
    strings like \"sh -c\". In these cases, you may be lucky and the encoded blob
    will also be logged. Otherwise, all you \n    will see is the {base64} decoding
    command, as the encoded blob was already interpreted by the shell. \n  condition:
    >\n    spawned_process \n    and container \n    and base64_decoding \n    and
    not container.image.repository in (known_decode_payload_containers)\n  output:
    Decoding Payload in Container (evt_type=%evt.type user=%user.name user_uid=%user.uid
    user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname
    command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n
    \ priority: INFO\n  tags: [maturity_sandbox, container, process, mitre_command_and_control,
    T1132] \n- list: recon_binaries\n  items: [w, whoami, id, who, uname]\n\n- condition:
    (proc.name in (recon_binaries))\n  macro: recon_binaries_procs\n\n- rule: Basic
    Interactive Reconnaissance\n  desc: >\n    This rule detects basic interactive
    reconnaissance commands that are typically run by unsophisticated attackers or
    used \n    in internal Red Team exercises. Interactive is defined as a terminal
    being present (proc.tty != 0). This could be any \n    form of reverse shell or
    usage of kubectl exec or ssh etc. In addition, filtering for the process being
    the process group  \n    leader indicates that the command was \"directly\" typed
    into the terminal and not run as a result of a script. This rule \n    is a basic
    auditing or template rule. You can expand the list of reconnaissance commands,
    such as by adding \"ls\". Common \n    anti-patterns are SRE activity or debugging,
    but it is still worth capturing this generically. Typically, you would expect
    \n    other rules to fire as well in relation to this activity.\n  condition:
    >\n    spawned_process \n    and recon_binaries_procs \n    and proc.tty != 0
    \n    and proc.is_vpgid_leader=true\n  output: Basic Interactive Reconnaissance
    (evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid
    process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline
    terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)\n  priority: NOTICE\n
    \ tags: [maturity_sandbox, host, container, process, mitre_reconnaissance, TA0043]\n"
{{- end }}